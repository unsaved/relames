defaultTasks 'jar'

buildscript {
    repositories { mavenCentral() }
    dependencies {
        classpath 'com.admc:gradle-javaPropFile-plugin:latest.milestone'
        classpath 'com.admc:gradle-ivyxml-plugin:latest.milestone'
    }
}

apply plugin: 'java'
apply plugin: 'ivyxml'
apply plugin: 'javaPropFile'

def localGradleFile = file('local.gradle')
if (localGradleFile.isFile()) {
    logger.info('''Executing optional build file 'localGradleFile'.''')
    apply from: localGradleFile
}

// Defaults that can be overridden with property files:
sourceCompatibility = '1.2'
targetCompatibility = sourceCompatibility
project.setProperty('org.name', System.properties['user.name'])
project.setProperty('jar.title', 'Customization')

propFileLoader.typeCasting = true
propFileLoader.traditionalPropertiesInit()

repositories { mavenCentral() }

//  Work-around for Gradle bug where Runtime classpath must include every
//  Compilation classpath element:
configurations { compileOnly }

task noop << { }
noop.description = 'Noop task for Gradle testing'

project.rtLibs = null
jar { doFirst {
    project.rtLibs = []
    Set<File> runtimeOnlyFiles = configurations.compileOnly.files as Set<File>
    configurations.runtime.files.each {
        if (!runtimeOnlyFiles.contains(it)) project.rtLibs << it.name
    }
    jar { manifest { attributes(
        'Main-Class': 'com.sun.msv.schematron.Driver',
        'Class-Path': project.rtLibs.join(' '),
        'Specification-Title': 'Relames',
        'Specification-Version': project.upstreamVersion,
        'Specification-Vendor': 'Sun Microsystems, Inc.',
        'Implementation-Title': project.property('jar.title'),
        'Implementation-Version': project.version,
        'Implementation-Vendor': project.property('org.name')
    ) } }
} }

// This task only for SCM administrator.  Update version and execute this task.
task updateWrapper(type: Wrapper) { doFirst {
    assert project.hasProperty('newVersion') :
        '''Property 'newVersion' is required for task 'updateWrapper'.'''
    assert project.newVersion == gradle.gradleVersion :
        "You invoked Gradle system with version $gradle.gradleVersion instead of desired version $project.newVersion"
} }
updateWrapper << {
    gradleVersion = project['newVersion']
    println 'WARNING:  Merge our customizations into the newly-generated wrapper scripts'
}
updateWrapper.description = 'Update Gradle version.  For SCM Administrators.'

task serialver(dependsOn: compileJava) << {
    assert project.hasProperty('className'):
            '''Property 'className' is required for task 'serialver'.'''
    String fileSep = System.properties['file.separator']
    // Could alternatively use Gradle's ExecSpec via exec(...)
    String javaHome = System.properties['java.home']
    String javacHome = (javaHome.endsWith("jre")
            ? javaHome.substring(0, javaHome.length() - "/jre".length())
            : javaHome)
    Process process = new ProcessBuilder([
        javacHome + fileSep + 'bin' + fileSep + 'serialver',
        '-classpath',
        'build/classes/main' + System.properties['path.separator']
                + configurations.runtime.asPath,
        project.property('className')
    ]).redirectErrorStream(true).start()
    // Must read input before waitFor-ing
    File outFile = new File(System.properties['java.io.tmpdir'],
                'serialVer-' + System.properties['user.name'] + '.txt')
    process.inputStream.eachLine { println it; outFile.write(it + '\n') }
    assert process.waitFor() == 0:  '''Execution of 'serialver' failed'''
    println """Also written to file '$outFile.absolutePath'
so you can read it into your editor."""
}
serialver.description = "Generates Java serialversion for specified 'classname'"

task checkTabs << {
    FileTree tree = fileTree(dir: '.')
    tree.exclude '**/.*/**'
    tree.include  '*.*'
    tree.include  'gradlew'
    tree.include  'src/**'
    tree.include  'doc/**'
    tree.include  'schemas/**'
    def tabFiles = []
    tree.each { if (it.text.indexOf('\t') > -1) tabFiles << relativePath(it) }
    if (tabFiles.size() > 0) println '  ' + tabFiles.join('\n  ')
}
checkTabs.description = 'Reports on any text files containing tab characters'

task zip(dependsOn: jar, type: Zip) {
    from configurations.runtime.allArtifacts.files
    from configurations.runtime
    from new File(buildDir, 'filtered-docs')
    into(project.name + '-' + project.version)
    exclude '**/crimson-*.jar'
}
zip.description =
        'Build zip of end-user executable relames jar with dependencies'

compileJava.dependsOn << { verifyResolve(configurations.compile) }
zip.dependsOn << { verifyResolve(configurations.runtime) }

import java.text.SimpleDateFormat
import org.apache.tools.ant.filters.ReplaceTokens
import org.apache.tools.ant.filters.FixCrLfFilter
zip { doFirst {
    copy {
        from 'doc'
        into new File(buildDir, 'filtered-docs')
        exclude '**/.*/**'
        filter(ReplaceTokens, tokens: [
            VERSION: (upstreamVersion
                    + ' (ADMC Relames v. ' + project.version + ')'),
            YEAR: new SimpleDateFormat("yyyy").format(new Date())
        ])
        //Ask how to do this at Gradle forum:
        //filter(FixCrLfFilter, eol: 'lf')
    }
} }

ivyxml.load()

task sourcesJar(type: Jar, dependsOn:classes) {
     classifier = 'sources'
     from sourceSets.main.allSource
}
sourcesJar.description = 'Build sources jar file'

task javadocJar(type: Jar, dependsOn:javadoc) {
     classifier = 'javadoc'
     from javadoc.destinationDir
}
javadocJar.description = 'Build javadoc jar file'

import org.gradle.api.artifacts.ModuleDependency
import org.gradle.api.artifacts.DependencyArtifact
import java.util.regex.Pattern
/**
 * Throws if any dependencies of the specified Configuration are not satisfied
 *
 * @throws GradleException containing list of non-satisfied dependencies
 */
void verifyResolve(config) {
    Set<String> artifactSet = [] as Set
    String classifierStr
    boolean satisfied
    List<ModuleDependency> unsatisfiedDeps = []
    List<DependencyArtifact> unsatisfiedArts = []
    config.allDependencies.each { it.artifacts.each {
        // The ModuleDependencies only have artifict members if either
        // classifier or extension/type are specified for the dependency.
        // If neither is, then we'll check the dependency in the findAll
        // loop below.
        DependencyArtifact depArt ->
        classifierStr =
                (depArt.classifier == null) ? '' : ('-' + depArt.classifier)
        Pattern pat = Pattern.compile(
                depArt.name + '-.+' + classifierStr + '.' + depArt.extension)
        satisfied = false
        for (File f in config.files) {
            if (pat.matcher(f.name).matches()) {
                satisfied = true
                break
            }
        }
        if (!satisfied) {
            unsatisfiedDeps << it
            unsatisfiedArts << depArt
        }
    } }
    config.allDependencies.findAll { it.artifacts.size() == 0 }.each {
        ModuleDependency dep ->
        Pattern pat = Pattern.compile(
                dep.name + '-' + dep.version + '[.-].+')
        satisfied = false
        for (File f in config.files) {
            if (pat.matcher(f.name).matches()) {
                satisfied = true
                break
            }
        }
        if (!satisfied) {
            unsatisfiedDeps << dep
            unsatisfiedArts << null
        }
    }
    if (unsatisfiedDeps.size() == 0) return
    StringBuilder sb = new StringBuilder()
    DependencyArtifact depArt
    int oneBasedInt
    unsatisfiedDeps.eachWithIndex{ ModuleDependency dep, int i ->
        depArt = unsatisfiedArts[i]
        sb.append('    ').append(i + 1)
        sb.append(": $dep.group:$dep.name:$dep.version")
        if (depArt != null) {
            sb.append('  ARTIFACT: ').append("$depArt.name $depArt.extension")
            if (depArt.classifier != null)
                sb.append(" (classifier '$depArt.classifier')")
        }
        sb.append('\n')
    }
    throw new GradleException(
        "Unsatisfied dependencies for configuration '$config.name':\n" + sb)
}
